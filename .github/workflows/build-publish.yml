name: build-publish

on:
  workflow_dispatch:
  push:
    branches:
      - main
    tags:
      - "v*"
    paths:
      - base/**
      - policy/**
      - charts/**
      - frontend/**
      - Makefile
      - .github/syft-os.yaml
      - .github/grype-os.yaml
      - .github/workflows/build-publish.yml

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REG: ghcr.io/${{ github.repository_owner }}
  PLATFORMS: linux/amd64,linux/arm64
  IS_ACT: "false"

concurrency:
  group: ci-images-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-base:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@ff7abcd0c3c05ccf6adc123a8cd1fd4fb30fb493
      - name: Detect act
        run: |
          if [ "${ACT:-}" = "true" ] || [ "${IS_ACT:-}" = "true" ]; then
            echo "IS_ACT=true" >> "$GITHUB_ENV"
          fi
      - if: env.IS_ACT != 'true'
        uses: docker/setup-qemu-action@v3
      - if: env.IS_ACT != 'true'
        uses: docker/setup-buildx-action@v3
      - name: Adjust platforms for act
        if: env.IS_ACT == 'true'
        run: |
          # When running under act (local), restrict to a single platform so
          # docker buildx --load doesn't attempt to export a multi-arch manifest
          # which the local docker exporter can't handle. Preserve multi-arch in CI.
          echo "PLATFORMS=linux/amd64" >> "$GITHUB_ENV"
      - name: Compute tags
        id: meta
        env:
          IMAGE: ci-base
        run: |
          set -euo pipefail
          TAGS="${REG}/${IMAGE}:latest"
          # Always add an immutable date+sha tag on branch builds
          DATE_UTC=$(date -u +%Y.%m.%d)
          SHORT_SHA=${GITHUB_SHA::8}
          TAGS+=$'\n'"${REG}/${IMAGE}:${DATE_UTC}-${SHORT_SHA}"
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]] && [[ "${GITHUB_REF_NAME:-}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"; MINOR="${BASH_REMATCH[2]}"; PATCH="${BASH_REMATCH[3]}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}.${MINOR}.${PATCH}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}.${MINOR}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}"
          fi
          {
            echo "tags<<EOF"
            echo "$TAGS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
      - name: Compute immutable ref
        id: imm
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail
          best=""
          while IFS= read -r line; do
            case "$line" in
              *:v[0-9]*.[0-9]*.[0-9]*) best="$line"; break;;
              *:[0-9][0-9][0-9][0-9].*) if [ -z "$best" ]; then best="$line"; fi;;
            esac
          done < <(printf "%s\n" "${TAGS}")
          if [ -z "$best" ]; then
            echo "No immutable tag found; fallback to first entry" >&2
            best=$(printf "%s\n" "${TAGS}" | head -n1)
          fi
          tag_only="${best##*:}"
          echo "ref=$best" >> "$GITHUB_OUTPUT"
          echo "tag=$tag_only" >> "$GITHUB_OUTPUT"
      - name: Login GHCR
        if: ${{ env.IS_ACT != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build & load base (act/local)
        if: env.IS_ACT == 'true'
        id: base-act
        run: |
          set -euo pipefail
          # Use buildx directly with --load for local runs to avoid manifest-list exports
          TAGS="${{ steps.meta.outputs.tags }}"
          # Build and load the first tag; tags may contain newlines, so pick the first
          FIRST_TAG=$(echo "$TAGS" | head -n1)
          mkdir -p ./artifacts
          # Capture build logs to artifacts so act diagnostics include them.
          # Under act, avoid buildx docker-container builder to reduce memory usage.
          # Use classic docker build with BuildKit and local base tagging.
          DOCKER_BUILDKIT=1 docker build --pull=false -t "$FIRST_TAG" -t ci-base:localtest \
            --build-arg BASE_REF=ci-base:localtest \
            --build-arg SKIP_TOOLS=1 \
            --build-arg SKIP_VENV=1 \
            --build-arg ENFORCE_CHECKSUMS=0 \
            ./base 2>&1 | tee ./artifacts/build-base-output.log
      - name: Build & push base (CI)
        if: env.IS_ACT != 'true'
        id: base
        uses: docker/build-push-action@v6
        with:
          context: ./base
          push: ${{ env.IS_ACT != 'true' }}
          load: ${{ env.IS_ACT == 'true' }}
          tags: ${{ steps.meta.outputs.tags }}
          platforms: ${{ env.PLATFORMS }}
          provenance: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
      - name: Install syft & grype (pinned)
        if: ${{ env.IS_ACT != 'true' }}
        uses: ./.github/actions/install-supplychain-tools
        with:
          syft-version: "0.96.0"
          grype-version: "0.69.1"
          syft-sha: "abc1b66ba07241eaa667a78900dabab4a4e7a96a1776b39628a4de3b61dfa30d"
          grype-sha: "53ad7a96d0561fdacc82519972025ba0f1a74e16edfdf628d4ce16cc3c714817"
      - name: Sanity check (base image)
        if: ${{ env.IS_ACT != 'true' }}
        run: |
          docker run --rm "${{ steps.imm.outputs.ref }}" yq --version
          docker run --rm "${{ steps.imm.outputs.ref }}" python3 --version
          docker run --rm "${{ steps.imm.outputs.ref }}" node --version
          docker run --rm "${{ steps.imm.outputs.ref }}" syft version
          docker run --rm "${{ steps.imm.outputs.ref }}" cosign version
      - name: Generate SBOM (base)
        if: ${{ env.IS_ACT != 'true' }}
        run: syft "${{ steps.imm.outputs.ref }}" -o spdx-json > sbom-ci-base.spdx.json
      - name: Generate SBOM (base, OS-only)
        if: ${{ env.IS_ACT != 'true' }}
        run: syft -c .github/syft-os.yaml "${{ steps.imm.outputs.ref }}" -o syft-json > sbom-ci-base-os.syft.json
      - name: Post-filter SBOM to OS-only (base)
        if: ${{ env.IS_ACT != 'true' }}
        run: jq '.artifacts |= map(select(.type=="apk" or .type=="deb" or .type=="rpm"))' sbom-ci-base-os.syft.json > sbom-ci-base-os.syft.os-only.json
      - name: Vulnerability scan (base)
        if: ${{ env.IS_ACT != 'true' }}
        env:
          GRYPE_CHECK_FOR_APP_UPDATE: "false"
        run: grype -c .github/grype-os.yaml sbom:sbom-ci-base-os.syft.os-only.json --fail-on critical --only-fixed --add-cpes-if-none
      - name: Upload SBOM artifact (base)
        if: ${{ always() && env.IS_ACT != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-ci-base
          path: sbom-ci-base.spdx.json
      - name: Summarize digest (base)
        if: env.IS_ACT != 'true'
        run: echo "ci-base@${{ steps.base.outputs.digest }}" >> "$GITHUB_STEP_SUMMARY"

  build-policy:
    needs: build-base
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@ff7abcd0c3c05ccf6adc123a8cd1fd4fb30fb493
      - name: Detect act
        run: |
          if [ "${ACT:-}" = "true" ] || [ "${IS_ACT:-}" = "true" ]; then
            echo "IS_ACT=true" >> "$GITHUB_ENV"
          fi
      - if: env.IS_ACT != 'true'
        uses: docker/setup-qemu-action@v3
      - if: env.IS_ACT != 'true'
        uses: docker/setup-buildx-action@v3
      - name: Adjust platforms for act
        if: env.IS_ACT == 'true'
        run: |
          # Limit to single-platform under act to avoid buildx manifest list errors
          echo "PLATFORMS=linux/amd64" >> "$GITHUB_ENV"
      - name: Compute tags
        id: meta
        env:
          IMAGE: ci-policy
        run: |
          set -euo pipefail
          TAGS="${REG}/${IMAGE}:latest"
          DATE_UTC=$(date -u +%Y.%m.%d)
          SHORT_SHA=${GITHUB_SHA::8}
          TAGS+=$'\n'"${REG}/${IMAGE}:${DATE_UTC}-${SHORT_SHA}"
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]] && [[ "${GITHUB_REF_NAME:-}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"; MINOR="${BASH_REMATCH[2]}"; PATCH="${BASH_REMATCH[3]}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}.${MINOR}.${PATCH}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}.${MINOR}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}"
          fi
          {
            echo "tags<<EOF"
            echo "$TAGS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
      - name: Compute immutable ref
        id: imm
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail
          best=""
          while IFS= read -r line; do
            case "$line" in
              *:v[0-9]*.[0-9]*.[0-9]*) best="$line"; break;;
              *:[0-9][0-9][0-9][0-9].*) if [ -z "$best" ]; then best="$line"; fi;;
            esac
          done < <(printf "%s\n" "${TAGS}")
          if [ -z "$best" ]; then
            best=$(printf "%s\n" "${TAGS}" | head -n1)
          fi
          tag_only="${best##*:}"
          echo "ref=$best" >> "$GITHUB_OUTPUT"
          echo "tag=$tag_only" >> "$GITHUB_OUTPUT"
      - name: Patch Dockerfile placeholders (policy)
        run: |
          sed -i 's|ghcr.io/<ORG>|ghcr.io/${{ github.repository_owner }}|g' policy/Dockerfile || true
          sed -i 's|ghcr.io/nektos/ci-base|ghcr.io/${{ github.repository_owner }}/ci-base|g' policy/Dockerfile || true
      - name: Login GHCR
        if: ${{ env.IS_ACT != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build & load policy (act/local)
        if: env.IS_ACT == 'true'
        id: policy-act
        run: |
          set -euo pipefail
          TAGS="${{ steps.meta.outputs.tags }}"
          FIRST_TAG=$(echo "$TAGS" | head -n1)
          mkdir -p ./artifacts
          # Use local base image under act to avoid GHCR pulls.
          # Build overlays with the classic docker builder (BuildKit enabled) so the
          # daemon can consume the locally tagged base image (ci-base:localtest)
          # without attempting a registry pull.
          DOCKER_BUILDKIT=1 docker build --pull=false -t "$FIRST_TAG" \
            --build-arg BASE_REF=ci-base:localtest \
            ./policy 2>&1 | tee ./artifacts/build-policy-output.log
      - name: Build & push policy (CI)
        if: env.IS_ACT != 'true'
        id: policy
        uses: docker/build-push-action@v6
        with:
          context: ./policy
          push: ${{ env.IS_ACT != 'true' }}
          tags: ${{ steps.meta.outputs.tags }}
          platforms: ${{ env.PLATFORMS }}
          provenance: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
      - name: Install syft & grype (pinned)
        if: ${{ env.IS_ACT != 'true' }}
        uses: ./.github/actions/install-supplychain-tools
        with:
          syft-version: "0.96.0"
          grype-version: "0.69.1"
          syft-sha: "abc1b66ba07241eaa667a78900dabab4a4e7a96a1776b39628a4de3b61dfa30d"
          grype-sha: "53ad7a96d0561fdacc82519972025ba0f1a74e16edfdf628d4ce16cc3c714817"
      - name: Sanity check (policy image)
        if: ${{ env.IS_ACT != 'true' }}
        run: |
          docker run --rm "${{ steps.imm.outputs.ref }}" opa version
          docker run --rm "${{ steps.imm.outputs.ref }}" kyverno version
      - name: Generate SBOM (policy)
        if: ${{ env.IS_ACT != 'true' }}
        run: syft "${{ steps.imm.outputs.ref }}" -o spdx-json > sbom-ci-policy.spdx.json
      - name: Generate SBOM (policy, OS-only)
        if: ${{ env.IS_ACT != 'true' }}
        run: syft -c .github/syft-os.yaml "${{ steps.imm.outputs.ref }}" -o syft-json > sbom-ci-policy-os.syft.json
      - name: Post-filter SBOM to OS-only (policy)
        if: ${{ env.IS_ACT != 'true' }}
        run: jq '.artifacts |= map(select(.type=="apk" or .type=="deb" or .type=="rpm"))' sbom-ci-policy-os.syft.json > sbom-ci-policy-os.syft.os-only.json
      - name: Vulnerability scan (policy)
        if: ${{ env.IS_ACT != 'true' }}
        env:
          GRYPE_CHECK_FOR_APP_UPDATE: "false"
        run: grype -c .github/grype-os.yaml sbom:sbom-ci-policy-os.syft.os-only.json --fail-on critical --only-fixed --add-cpes-if-none
      - name: Upload SBOM artifact (policy)
        if: ${{ always() && env.IS_ACT != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-ci-policy
          path: sbom-ci-policy.spdx.json
      - name: Summarize digest (policy)
        if: env.IS_ACT != 'true'
        run: echo "ci-policy@${{ steps.policy.outputs.digest }}" >> "$GITHUB_STEP_SUMMARY"

  build-charts:
    needs: build-base
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@ff7abcd0c3c05ccf6adc123a8cd1fd4fb30fb493
      - name: Detect act
        run: |
          if [ "${ACT:-}" = "true" ] || [ "${IS_ACT:-}" = "true" ]; then
            echo "IS_ACT=true" >> "$GITHUB_ENV"
          fi
      - if: env.IS_ACT != 'true'
        uses: docker/setup-qemu-action@v3
      - if: env.IS_ACT != 'true'
        uses: docker/setup-buildx-action@v3
      - name: Adjust platforms for act
        if: env.IS_ACT == 'true'
        run: |
          echo "PLATFORMS=linux/amd64" >> "$GITHUB_ENV"
      - name: Compute tags
        id: meta
        env:
          IMAGE: ci-charts
        run: |
          set -euo pipefail
          TAGS="${REG}/${IMAGE}:latest"
          DATE_UTC=$(date -u +%Y.%m.%d)
          SHORT_SHA=${GITHUB_SHA::8}
          TAGS+=$'\n'"${REG}/${IMAGE}:${DATE_UTC}-${SHORT_SHA}"
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]] && [[ "${GITHUB_REF_NAME:-}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"; MINOR="${BASH_REMATCH[2]}"; PATCH="${BASH_REMATCH[3]}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}.${MINOR}.${PATCH}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}.${MINOR}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}"
          fi
          {
            echo "tags<<EOF"
            echo "$TAGS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
      - name: Compute immutable ref
        id: imm
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail
          best=""
          while IFS= read -r line; do
            case "$line" in
              *:v[0-9]*.[0-9]*.[0-9]*) best="$line"; break;;
              *:[0-9][0-9][0-9][0-9].*) if [ -z "$best" ]; then best="$line"; fi;;
            esac
          done < <(printf "%s\n" "${TAGS}")
          if [ -z "$best" ]; then
            best=$(printf "%s\n" "${TAGS}" | head -n1)
          fi
          tag_only="${best##*:}"
          echo "ref=$best" >> "$GITHUB_OUTPUT"
          echo "tag=$tag_only" >> "$GITHUB_OUTPUT"
      - name: Patch Dockerfile placeholders (charts)
        run: |
          sed -i 's|ghcr.io/<ORG>|ghcr.io/${{ github.repository_owner }}|g' charts/Dockerfile || true
          sed -i 's|ghcr.io/nektos/ci-base|ghcr.io/${{ github.repository_owner }}/ci-base|g' charts/Dockerfile || true
      - name: Login GHCR
        if: ${{ env.IS_ACT != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build & load charts (act/local)
        if: env.IS_ACT == 'true'
        id: charts-act
        run: |
          set -euo pipefail
          TAGS="${{ steps.meta.outputs.tags }}"
          FIRST_TAG=$(echo "$TAGS" | head -n1)
          mkdir -p ./artifacts
          # Use local base image under act to avoid GHCR pulls.
          # Use host networking to avoid local bridge DNS/TLS oddities under act
          DOCKER_BUILDKIT=1 docker build --pull=false --network=host -t "$FIRST_TAG" \
            --build-arg BASE_REF=ci-base:localtest \
            ${HELM_BASE_URL:+--build-arg HELM_BASE_URL=${HELM_BASE_URL}} \
            ${HELM_GITHUB_BASE_URL:+--build-arg HELM_GITHUB_BASE_URL=${HELM_GITHUB_BASE_URL}} \
            ${HELM_TARBALL_SHA256:+--build-arg HELM_TARBALL_SHA256=${HELM_TARBALL_SHA256}} \
            ./charts 2>&1 | tee ./artifacts/build-charts-output.log
      - name: Build & push charts (CI)
        if: env.IS_ACT != 'true'
        id: charts
        uses: docker/build-push-action@v6
        with:
          context: ./charts
          push: ${{ env.IS_ACT != 'true' }}
          tags: ${{ steps.meta.outputs.tags }}
          platforms: ${{ env.PLATFORMS }}
          provenance: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
      - name: Install syft & grype (pinned)
        if: ${{ env.IS_ACT != 'true' }}
        uses: ./.github/actions/install-supplychain-tools
        with:
          syft-version: "0.96.0"
          grype-version: "0.69.1"
          syft-sha: "abc1b66ba07241eaa667a78900dabab4a4e7a96a1776b39628a4de3b61dfa30d"
          grype-sha: "53ad7a96d0561fdacc82519972025ba0f1a74e16edfdf628d4ce16cc3c714817"
      - name: Sanity check (charts image)
        if: ${{ env.IS_ACT != 'true' }}
        run: |
          docker run --rm "${{ steps.imm.outputs.ref }}" helm version --short
          docker run --rm "${{ steps.imm.outputs.ref }}" kubeconform -v
          docker run --rm "${{ steps.imm.outputs.ref }}" sh -lc 'HELM_PLUGINS=/usr/local/helm-plugins helm unittest --help >/dev/null 2>&1 && echo ok || (echo fail; exit 1)'
          docker run --rm "${{ steps.imm.outputs.ref }}" ct version || docker run --rm "${{ steps.imm.outputs.ref }}" ct --help
      - name: Generate SBOM (charts)
        if: ${{ env.IS_ACT != 'true' }}
        run: syft "${{ steps.imm.outputs.ref }}" -o spdx-json > sbom-ci-charts.spdx.json
      - name: Generate SBOM (charts, OS-only)
        if: ${{ env.IS_ACT != 'true' }}
        run: syft -c .github/syft-os.yaml "${{ steps.imm.outputs.ref }}" -o syft-json > sbom-ci-charts-os.syft.json
      - name: Post-filter SBOM to OS-only (charts)
        if: ${{ env.IS_ACT != 'true' }}
        run: jq '.artifacts |= map(select(.type=="apk" or .type=="deb" or .type=="rpm"))' sbom-ci-charts-os.syft.json > sbom-ci-charts-os.syft.os-only.json
      - name: Vulnerability scan (charts)
        if: ${{ env.IS_ACT != 'true' }}
        env:
          GRYPE_CHECK_FOR_APP_UPDATE: "false"
        run: grype -c .github/grype-os.yaml sbom:sbom-ci-charts-os.syft.os-only.json --fail-on critical --only-fixed --add-cpes-if-none
      - name: Upload SBOM artifact (charts)
        if: ${{ always() && env.IS_ACT != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-ci-charts
          path: sbom-ci-charts.spdx.json
      - name: Summarize digest (charts)
        if: env.IS_ACT != 'true'
        run: echo "ci-charts@${{ steps.charts.outputs.digest }}" >> "$GITHUB_STEP_SUMMARY"
      - name: Compute published immutable tag for ci-charts
        if: env.IS_ACT != 'true'
        id: charts-tag
        run: |
          set -euo pipefail
          # Choose a stable, immutable tag to broadcast: prefer semver tag if present, else date+sha.
          best=""
          while IFS= read -r tag; do
            case "$tag" in
              *:v[0-9]*.[0-9]*.[0-9]*) best="$tag";;
              *:[0-9][0-9][0-9][0-9].*) if [ -z "$best" ]; then best="$tag"; fi;;
            esac
          done < <(printf "%s\n" "${{ steps.meta.outputs.tags }}")
          # Strip registry/repo prefix to get just the tag value after the last ':'
          ref_tag="${best##*:}"
          echo "tag=$ref_tag" >> "$GITHUB_OUTPUT"
          echo "Selected ci-charts tag: $ref_tag" >> "$GITHUB_STEP_SUMMARY"
      - name: Dispatch update to rulehub-charts (optional)
        if: env.IS_ACT != 'true'
        env:
          OWNER: ${{ github.repository_owner }}
          TAG: ${{ steps.charts-tag.outputs.tag }}
        run: |
          set -euo pipefail
          # Provide a PAT via env DISPATCH_TOKEN with repo:write scope to enable cross-repo dispatch.
          TOKEN="${DISPATCH_TOKEN:-}"
          if [ -z "$TOKEN" ]; then
            echo "CHARTS_REPO_TOKEN not set; skipping repository_dispatch to ${OWNER}/rulehub-charts" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi
          echo "Dispatching ci-image-published to ${OWNER}/rulehub-charts with tag=${TAG}"
          curl -sSf -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${OWNER}/rulehub-charts/dispatches \
            -d "$(jq -n --arg tag "$TAG" '{event_type:"ci-image-published", client_payload:{tag:$tag}}')"
          echo "repository_dispatch sent to ${OWNER}/rulehub-charts" >> "$GITHUB_STEP_SUMMARY"

  build-frontend:
    needs: build-base
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@ff7abcd0c3c05ccf6adc123a8cd1fd4fb30fb493
      - name: Detect act
        run: |
          if [ "${ACT:-}" = "true" ] || [ "${IS_ACT:-}" = "true" ]; then
            echo "IS_ACT=true" >> "$GITHUB_ENV"
          fi
      - if: env.IS_ACT != 'true'
        uses: docker/setup-qemu-action@v3
      - if: env.IS_ACT != 'true'
        uses: docker/setup-buildx-action@v3
      - name: Adjust platforms for act
        if: env.IS_ACT == 'true'
        run: |
          echo "PLATFORMS=linux/amd64" >> "$GITHUB_ENV"
      - name: Compute tags
        id: meta
        env:
          IMAGE: ci-frontend
        run: |
          set -euo pipefail
          TAGS="${REG}/${IMAGE}:latest"
          DATE_UTC=$(date -u +%Y.%m.%d)
          SHORT_SHA=${GITHUB_SHA::8}
          TAGS+=$'\n'"${REG}/${IMAGE}:${DATE_UTC}-${SHORT_SHA}"
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]] && [[ "${GITHUB_REF_NAME:-}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"; MINOR="${BASH_REMATCH[2]}"; PATCH="${BASH_REMATCH[3]}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}.${MINOR}.${PATCH}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}.${MINOR}"
            TAGS+=$'\n'"${REG}/${IMAGE}:v${MAJOR}"
          fi
          {
            echo "tags<<EOF"
            echo "$TAGS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
      - name: Compute immutable ref
        id: imm
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail
          best=""
          while IFS= read -r line; do
            case "$line" in
              *:v[0-9]*.[0-9]*.[0-9]*) best="$line"; break;;
              *:[0-9][0-9][0-9][0-9].*) if [ -z "$best" ]; then best="$line"; fi;;
            esac
          done < <(printf "%s\n" "${TAGS}")
          if [ -z "$best" ]; then
            best=$(printf "%s\n" "${TAGS}" | head -n1)
          fi
          tag_only="${best##*:}"
          echo "ref=$best" >> "$GITHUB_OUTPUT"
          echo "tag=$tag_only" >> "$GITHUB_OUTPUT"
      - name: Patch Dockerfile placeholders (frontend)
        run: |
          sed -i 's|ghcr.io/<ORG>|ghcr.io/${{ github.repository_owner }}|g' frontend/Dockerfile || true
          sed -i 's|ghcr.io/nektos/ci-base|ghcr.io/${{ github.repository_owner }}/ci-base|g' frontend/Dockerfile || true
      - name: Login GHCR
        if: ${{ env.IS_ACT != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build & load frontend (act/local)
        if: env.IS_ACT == 'true'
        id: frontend-act
        run: |
          set -euo pipefail
          TAGS="${{ steps.meta.outputs.tags }}"
          FIRST_TAG=$(echo "$TAGS" | head -n1)
          mkdir -p ./artifacts
          # Use local base image under act to avoid GHCR pulls.
          DOCKER_BUILDKIT=1 docker build --pull=false -t "$FIRST_TAG" \
            --build-arg BASE_REF=ci-base:localtest \
            ./frontend 2>&1 | tee ./artifacts/build-frontend-output.log
      - name: Build & push frontend (CI)
        if: env.IS_ACT != 'true'
        id: frontend
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          push: ${{ env.IS_ACT != 'true' }}
          tags: ${{ steps.meta.outputs.tags }}
          platforms: ${{ env.PLATFORMS }}
          provenance: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
      - name: Install syft & grype (pinned)
        if: ${{ env.IS_ACT != 'true' }}
        uses: ./.github/actions/install-supplychain-tools
        with:
          syft-version: "0.96.0"
          grype-version: "0.69.1"
          syft-sha: "abc1b66ba07241eaa667a78900dabab4a4e7a96a1776b39628a4de3b61dfa30d"
          grype-sha: "53ad7a96d0561fdacc82519972025ba0f1a74e16edfdf628d4ce16cc3c714817"
      - name: Sanity check (frontend image)
        if: ${{ env.IS_ACT != 'true' }}
        run: |
          docker run --rm "${{ steps.imm.outputs.ref }}" node --version
          docker run --rm "${{ steps.imm.outputs.ref }}" npm --version
          docker run --rm "${{ steps.imm.outputs.ref }}" corepack --version || true
      - name: Generate SBOM (frontend)
        if: ${{ env.IS_ACT != 'true' }}
        run: syft "${{ steps.imm.outputs.ref }}" -o spdx-json > sbom-ci-frontend.spdx.json
      - name: Generate SBOM (frontend, OS-only)
        if: ${{ env.IS_ACT != 'true' }}
        run: syft -c .github/syft-os.yaml "${{ steps.imm.outputs.ref }}" -o syft-json > sbom-ci-frontend-os.syft.json
      - name: Post-filter SBOM to OS-only (frontend)
        if: ${{ env.IS_ACT != 'true' }}
        run: jq '.artifacts |= map(select(.type=="apk" or .type=="deb" or .type=="rpm"))' sbom-ci-frontend-os.syft.json > sbom-ci-frontend-os.syft.os-only.json
      - name: Vulnerability scan (frontend)
        if: ${{ env.IS_ACT != 'true' }}
        env:
          GRYPE_CHECK_FOR_APP_UPDATE: "false"
        run: grype -c .github/grype-os.yaml sbom:sbom-ci-frontend-os.syft.os-only.json --fail-on critical --only-fixed --add-cpes-if-none
      - name: Upload SBOM artifact (frontend)
        if: ${{ always() && env.IS_ACT != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-ci-frontend
          path: sbom-ci-frontend.spdx.json
      - name: Summarize digest (frontend)
        if: env.IS_ACT != 'true'
        run: echo "ci-frontend@${{ steps.frontend.outputs.digest }}" >> "$GITHUB_STEP_SUMMARY"
